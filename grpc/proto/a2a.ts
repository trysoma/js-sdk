// @generated by protobuf-ts 2.11.1 with parameter server_grpc1
// @generated from protobuf file "a2a.proto" (package "a2a.v1", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
import { Struct } from "./google/protobuf/struct";
// /////// Data Model ////////////

/**
 * Configuration of a send message request.
 *
 * @generated from protobuf message a2a.v1.SendMessageConfiguration
 */
export interface SendMessageConfiguration {
    /**
     * The output modes that the agent is expected to respond with.
     *
     * @generated from protobuf field: repeated string accepted_output_modes = 1
     */
    acceptedOutputModes: string[];
    /**
     * A configuration of a webhook that can be used to receive updates
     *
     * @generated from protobuf field: a2a.v1.PushNotificationConfig push_notification = 2
     */
    pushNotification?: PushNotificationConfig;
    /**
     * The maximum number of messages to include in the history. if 0, the
     * history will be unlimited.
     *
     * @generated from protobuf field: int32 history_length = 3
     */
    historyLength: number;
    /**
     * If true, the message will be blocking until the task is completed. If
     * false, the message will be non-blocking and the task will be returned
     * immediately. It is the caller's responsibility to check for any task
     * updates.
     *
     * @generated from protobuf field: bool blocking = 4
     */
    blocking: boolean;
}
/**
 * Task is the core unit of action for A2A. It has a current status
 * and when results are created for the task they are stored in the
 * artifact. If there are multiple turns for a task, these are stored in
 * history.
 *
 * @generated from protobuf message a2a.v1.Task
 */
export interface Task {
    /**
     * Unique identifier for a task, created by the A2A server.
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Unique identifier for the contextual collection of interactions (tasks
     * and messages). Created by the A2A server.
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The current status of a Task, including state and a message.
     *
     * @generated from protobuf field: a2a.v1.TaskStatus status = 3
     */
    status?: TaskStatus;
    /**
     * A set of output artifacts for a Task.
     *
     * @generated from protobuf field: repeated a2a.v1.Artifact artifacts = 4
     */
    artifacts: Artifact[];
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * The history of interactions from a task.
     *
     * @generated from protobuf field: repeated a2a.v1.Message history = 5
     */
    history: Message[];
    /**
     * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
     * A key/value object to store custom metadata about a task.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
}
/**
 * A container for the status of a task
 *
 * @generated from protobuf message a2a.v1.TaskStatus
 */
export interface TaskStatus {
    /**
     * The current state of this task
     *
     * @generated from protobuf field: a2a.v1.TaskState state = 1
     */
    state: TaskState;
    /**
     * A message associated with the status.
     *
     * @generated from protobuf field: a2a.v1.Message update = 2 [json_name = "message"]
     */
    update?: Message;
    /**
     * Timestamp when the status was recorded.
     * Example: "2023-10-27T10:00:00Z"
     *
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
     */
    timestamp?: Timestamp;
}
/**
 * Part represents a container for a section of communication content.
 * Parts can be purely textual, some sort of file (image, video, etc) or
 * a structured data blob (i.e. JSON).
 *
 * @generated from protobuf message a2a.v1.Part
 */
export interface Part {
    /**
     * @generated from protobuf oneof: part
     */
    part: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 1
         */
        text: string;
    } | {
        oneofKind: "file";
        /**
         * @generated from protobuf field: a2a.v1.FilePart file = 2
         */
        file: FilePart;
    } | {
        oneofKind: "data";
        /**
         * @generated from protobuf field: a2a.v1.DataPart data = 3
         */
        data: DataPart;
    } | {
        oneofKind: undefined;
    };
}
/**
 * FilePart represents the different ways files can be provided. If files are
 * small, directly feeding the bytes is supported via file_with_bytes. If the
 * file is large, the agent should read the content as appropriate directly
 * from the file_with_uri source.
 *
 * @generated from protobuf message a2a.v1.FilePart
 */
export interface FilePart {
    /**
     * @generated from protobuf oneof: file
     */
    file: {
        oneofKind: "fileWithUri";
        /**
         * @generated from protobuf field: string file_with_uri = 1
         */
        fileWithUri: string;
    } | {
        oneofKind: "fileWithBytes";
        /**
         * @generated from protobuf field: bytes file_with_bytes = 2
         */
        fileWithBytes: Uint8Array;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string mime_type = 3
     */
    mimeType: string;
}
/**
 * DataPart represents a structured blob. This is most commonly a JSON payload.
 *
 * @generated from protobuf message a2a.v1.DataPart
 */
export interface DataPart {
    /**
     * @generated from protobuf field: google.protobuf.Struct data = 1
     */
    data?: Struct;
}
/**
 * Message is one unit of communication between client and server. It is
 * associated with a context and optionally a task. Since the server is
 * responsible for the context definition, it must always provide a context_id
 * in its messages. The client can optionally provide the context_id if it
 * knows the context to associate the message to. Similarly for task_id,
 * except the server decides if a task is created and whether to include the
 * task_id.
 *
 * @generated from protobuf message a2a.v1.Message
 */
export interface Message {
    /**
     * The message id of the message. This is required and created by the
     * message creator.
     *
     * @generated from protobuf field: string message_id = 1
     */
    messageId: string;
    /**
     * The context id of the message. This is optional and if set, the message
     * will be associated with the given context.
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The task id of the message. This is optional and if set, the message
     * will be associated with the given task.
     *
     * @generated from protobuf field: string task_id = 3
     */
    taskId: string;
    /**
     * A role for the message.
     *
     * @generated from protobuf field: a2a.v1.Role role = 4
     */
    role: Role;
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * Content is the container of the message content.
     *
     * @generated from protobuf field: repeated a2a.v1.Part content = 5
     */
    content: Part[];
    /**
     * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
     * Any optional metadata to provide along with the message.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
    /**
     * The URIs of extensions that are present or contributed to this Message.
     *
     * @generated from protobuf field: repeated string extensions = 7
     */
    extensions: string[];
}
/**
 * Artifacts are the container for task completed results. These are similar
 * to Messages but are intended to be the product of a task, as opposed to
 * point-to-point communication.
 *
 * @generated from protobuf message a2a.v1.Artifact
 */
export interface Artifact {
    /**
     * Unique id for the artifact. It must be at least unique within a task.
     *
     * @generated from protobuf field: string artifact_id = 1
     */
    artifactId: string;
    /**
     * A human readable name for the artifact.
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * A human readable description of the artifact, optional.
     *
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * The content of the artifact.
     *
     * @generated from protobuf field: repeated a2a.v1.Part parts = 5
     */
    parts: Part[];
    /**
     * Optional metadata included with the artifact.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
    /**
     * The URIs of extensions that are present or contributed to this Artifact.
     *
     * @generated from protobuf field: repeated string extensions = 7
     */
    extensions: string[];
}
/**
 * TaskStatusUpdateEvent is a delta even on a task indicating that a task
 * has changed.
 *
 * @generated from protobuf message a2a.v1.TaskStatusUpdateEvent
 */
export interface TaskStatusUpdateEvent {
    /**
     * The id of the task that is changed
     *
     * @generated from protobuf field: string task_id = 1
     */
    taskId: string;
    /**
     * The id of the context that the task belongs to
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The new status of the task.
     *
     * @generated from protobuf field: a2a.v1.TaskStatus status = 3
     */
    status?: TaskStatus;
    /**
     * Whether this is the last status update expected for this task.
     *
     * @generated from protobuf field: bool final = 4
     */
    final: boolean;
    /**
     * Optional metadata to associate with the task update.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 5
     */
    metadata?: Struct;
}
/**
 * TaskArtifactUpdateEvent represents a task delta where an artifact has
 * been generated.
 *
 * @generated from protobuf message a2a.v1.TaskArtifactUpdateEvent
 */
export interface TaskArtifactUpdateEvent {
    /**
     * The id of the task for this artifact
     *
     * @generated from protobuf field: string task_id = 1
     */
    taskId: string;
    /**
     * The id of the context that this task belongs too
     *
     * @generated from protobuf field: string context_id = 2
     */
    contextId: string;
    /**
     * The artifact itself
     *
     * @generated from protobuf field: a2a.v1.Artifact artifact = 3
     */
    artifact?: Artifact;
    /**
     *  Whether this should be appended to a prior one produced
     *
     * @generated from protobuf field: bool append = 4
     */
    append: boolean;
    /**
     * Whether this represents the last part of an artifact
     *
     * @generated from protobuf field: bool last_chunk = 5
     */
    lastChunk: boolean;
    /**
     * Optional metadata associated with the artifact update.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 6
     */
    metadata?: Struct;
}
/**
 * Configuration for setting up push notifications for task updates.
 *
 * @generated from protobuf message a2a.v1.PushNotificationConfig
 */
export interface PushNotificationConfig {
    /**
     * A unique id for this push notification.
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Url to send the notification too
     *
     * @generated from protobuf field: string url = 2
     */
    url: string;
    /**
     * Token unique for this task/session
     *
     * @generated from protobuf field: string token = 3
     */
    token: string;
    /**
     * Information about the authentication to sent with the notification
     *
     * @generated from protobuf field: a2a.v1.AuthenticationInfo authentication = 4
     */
    authentication?: AuthenticationInfo;
}
/**
 * Defines authentication details, used for push notifications.
 *
 * @generated from protobuf message a2a.v1.AuthenticationInfo
 */
export interface AuthenticationInfo {
    /**
     * Supported authentication schemes - e.g. Basic, Bearer, etc
     *
     * @generated from protobuf field: repeated string schemes = 1
     */
    schemes: string[];
    /**
     * Optional credentials
     *
     * @generated from protobuf field: string credentials = 2
     */
    credentials: string;
}
/**
 * Defines additional transport information for the agent.
 *
 * @generated from protobuf message a2a.v1.AgentInterface
 */
export interface AgentInterface {
    /**
     * The url this interface is found at.
     *
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * The transport supported this url. This is an open form string, to be
     * easily extended for many transport protocols. The core ones officially
     * supported are JSONRPC, GRPC and HTTP+JSON.
     *
     * @generated from protobuf field: string transport = 2
     */
    transport: string;
}
/**
 * AgentCard conveys key information:
 * - Overall details (version, name, description, uses)
 * - Skills; a set of actions/solutions the agent can perform
 * - Default modalities/content types supported by the agent.
 * - Authentication requirements
 *
 * @generated from protobuf message a2a.v1.AgentCard
 */
export interface AgentCard {
    /**
     * The version of the A2A protocol this agent supports.
     *
     * @generated from protobuf field: string protocol_version = 16
     */
    protocolVersion: string;
    /**
     * A human readable name for the agent.
     * Example: "Recipe Agent"
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * A description of the agent's domain of action/solution space.
     * Example: "Agent that helps users with recipes and cooking."
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * A URL to the address the agent is hosted at. This represents the
     * preferred endpoint as declared by the agent.
     *
     * @generated from protobuf field: string url = 3
     */
    url: string;
    /**
     * The transport of the preferred endpoint. If empty, defaults to JSONRPC.
     *
     * @generated from protobuf field: string preferred_transport = 14
     */
    preferredTransport: string;
    /**
     * Announcement of additional supported transports. Client can use any of
     * the supported transports.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentInterface additional_interfaces = 15
     */
    additionalInterfaces: AgentInterface[];
    /**
     * The service provider of the agent.
     *
     * @generated from protobuf field: a2a.v1.AgentProvider provider = 4
     */
    provider?: AgentProvider;
    /**
     * The version of the agent.
     * Example: "1.0.0"
     *
     * @generated from protobuf field: string version = 5
     */
    version: string;
    /**
     * A url to provide additional documentation about the agent.
     *
     * @generated from protobuf field: string documentation_url = 6
     */
    documentationUrl: string;
    /**
     * A2A Capability set supported by the agent.
     *
     * @generated from protobuf field: a2a.v1.AgentCapabilities capabilities = 7
     */
    capabilities?: AgentCapabilities;
    /**
     * The security scheme details used for authenticating with this agent.
     *
     * @generated from protobuf field: map<string, a2a.v1.SecurityScheme> security_schemes = 8
     */
    securitySchemes: {
        [key: string]: SecurityScheme;
    };
    /**
     * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
     * Security requirements for contacting the agent.
     *
     * @generated from protobuf field: repeated a2a.v1.Security security = 9
     */
    security: Security[];
    /**
     * protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
     * The set of interaction modes that the agent supports across all skills.
     * This can be overridden per skill. Defined as mime types.
     *
     * @generated from protobuf field: repeated string default_input_modes = 10
     */
    defaultInputModes: string[];
    /**
     * The mime types supported as outputs from this agent.
     *
     * @generated from protobuf field: repeated string default_output_modes = 11
     */
    defaultOutputModes: string[];
    /**
     * Skills represent a unit of ability an agent can perform. This may
     * somewhat abstract but represents a more focused set of actions that the
     * agent is highly likely to succeed at.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentSkill skills = 12
     */
    skills: AgentSkill[];
    /**
     * Whether the agent supports providing an extended agent card when
     * the user is authenticated, i.e. is the card from .well-known
     * different than the card from GetAgentCard.
     *
     * @generated from protobuf field: bool supports_authenticated_extended_card = 13
     */
    supportsAuthenticatedExtendedCard: boolean;
}
/**
 * Represents information about the service provider of an agent.
 *
 * @generated from protobuf message a2a.v1.AgentProvider
 */
export interface AgentProvider {
    /**
     * The providers reference url
     * Example: "https://ai.google.dev"
     *
     * @generated from protobuf field: string url = 1
     */
    url: string;
    /**
     * The providers organization name
     * Example: "Google"
     *
     * @generated from protobuf field: string organization = 2
     */
    organization: string;
}
/**
 * Defines the A2A feature set supported by the agent
 *
 * @generated from protobuf message a2a.v1.AgentCapabilities
 */
export interface AgentCapabilities {
    /**
     * If the agent will support streaming responses
     *
     * @generated from protobuf field: bool streaming = 1
     */
    streaming: boolean;
    /**
     * If the agent can send push notifications to the clients webhook
     *
     * @generated from protobuf field: bool push_notifications = 2
     */
    pushNotifications: boolean;
    /**
     * Extensions supported by this agent.
     *
     * @generated from protobuf field: repeated a2a.v1.AgentExtension extensions = 3
     */
    extensions: AgentExtension[];
}
/**
 * A declaration of an extension supported by an Agent.
 *
 * @generated from protobuf message a2a.v1.AgentExtension
 */
export interface AgentExtension {
    /**
     * The URI of the extension.
     * Example: "https://developers.google.com/identity/protocols/oauth2"
     *
     * @generated from protobuf field: string uri = 1
     */
    uri: string;
    /**
     * A description of how this agent uses this extension.
     * Example: "Google OAuth 2.0 authentication"
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Whether the client must follow specific requirements of the extension.
     * Example: false
     *
     * @generated from protobuf field: bool required = 3
     */
    required: boolean;
    /**
     * Optional configuration for the extension.
     *
     * @generated from protobuf field: google.protobuf.Struct params = 4
     */
    params?: Struct;
}
/**
 * AgentSkill represents a unit of action/solution that the agent can perform.
 * One can think of this as a type of highly reliable solution that an agent
 * can be tasked to provide. Agents have the autonomy to choose how and when
 * to use specific skills, but clients should have confidence that if the
 * skill is defined that unit of action can be reliably performed.
 *
 * @generated from protobuf message a2a.v1.AgentSkill
 */
export interface AgentSkill {
    /**
     * Unique id of the skill within this agent.
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * A human readable name for the skill.
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * A human (or llm) readable description of the skill
     * details and behaviors.
     *
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * A set of tags for the skill to enhance categorization/utilization.
     * Example: ["cooking", "customer support", "billing"]
     *
     * @generated from protobuf field: repeated string tags = 4
     */
    tags: string[];
    /**
     * A set of example queries that this skill is designed to address.
     * These examples should help the caller to understand how to craft requests
     * to the agent to achieve specific goals.
     * Example: ["I need a recipe for bread"]
     *
     * @generated from protobuf field: repeated string examples = 5
     */
    examples: string[];
    /**
     * Possible input modalities supported.
     *
     * @generated from protobuf field: repeated string input_modes = 6
     */
    inputModes: string[];
    /**
     * Possible output modalities produced
     *
     * @generated from protobuf field: repeated string output_modes = 7
     */
    outputModes: string[];
}
/**
 * @generated from protobuf message a2a.v1.TaskPushNotificationConfig
 */
export interface TaskPushNotificationConfig {
    /**
     * name=tasks/{id}/pushNotificationConfigs/{id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: a2a.v1.PushNotificationConfig push_notification_config = 2
     */
    pushNotificationConfig?: PushNotificationConfig;
}
/**
 * protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
 *
 * @generated from protobuf message a2a.v1.StringList
 */
export interface StringList {
    /**
     * @generated from protobuf field: repeated string list = 1
     */
    list: string[];
}
/**
 * @generated from protobuf message a2a.v1.Security
 */
export interface Security {
    /**
     * @generated from protobuf field: map<string, a2a.v1.StringList> schemes = 1
     */
    schemes: {
        [key: string]: StringList;
    };
}
/**
 * @generated from protobuf message a2a.v1.SecurityScheme
 */
export interface SecurityScheme {
    /**
     * @generated from protobuf oneof: scheme
     */
    scheme: {
        oneofKind: "apiKeySecurityScheme";
        /**
         * @generated from protobuf field: a2a.v1.APIKeySecurityScheme api_key_security_scheme = 1
         */
        apiKeySecurityScheme: APIKeySecurityScheme;
    } | {
        oneofKind: "httpAuthSecurityScheme";
        /**
         * @generated from protobuf field: a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme = 2
         */
        httpAuthSecurityScheme: HTTPAuthSecurityScheme;
    } | {
        oneofKind: "oauth2SecurityScheme";
        /**
         * @generated from protobuf field: a2a.v1.OAuth2SecurityScheme oauth2_security_scheme = 3
         */
        oauth2SecurityScheme: OAuth2SecurityScheme;
    } | {
        oneofKind: "openIdConnectSecurityScheme";
        /**
         * @generated from protobuf field: a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4
         */
        openIdConnectSecurityScheme: OpenIdConnectSecurityScheme;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message a2a.v1.APIKeySecurityScheme
 */
export interface APIKeySecurityScheme {
    /**
     * Description of this security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * Location of the API key, valid values are "query", "header", or "cookie"
     *
     * @generated from protobuf field: string location = 2
     */
    location: string;
    /**
     * Name of the header, query or cookie parameter to be used.
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.HTTPAuthSecurityScheme
 */
export interface HTTPAuthSecurityScheme {
    /**
     * Description of this security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * The name of the HTTP Authentication scheme to be used in the
     * Authorization header as defined in RFC7235. The values used SHOULD be
     * registered in the IANA Authentication Scheme registry.
     * The value is case-insensitive, as defined in RFC7235.
     *
     * @generated from protobuf field: string scheme = 2
     */
    scheme: string;
    /**
     * A hint to the client to identify how the bearer token is formatted.
     * Bearer tokens are usually generated by an authorization server, so
     * this information is primarily for documentation purposes.
     *
     * @generated from protobuf field: string bearer_format = 3
     */
    bearerFormat: string;
}
/**
 * @generated from protobuf message a2a.v1.OAuth2SecurityScheme
 */
export interface OAuth2SecurityScheme {
    /**
     * Description of this security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * An object containing configuration information for the flow types supported
     *
     * @generated from protobuf field: a2a.v1.OAuthFlows flows = 2
     */
    flows?: OAuthFlows;
}
/**
 * @generated from protobuf message a2a.v1.OpenIdConnectSecurityScheme
 */
export interface OpenIdConnectSecurityScheme {
    /**
     * Description of this security scheme.
     *
     * @generated from protobuf field: string description = 1
     */
    description: string;
    /**
     * Well-known URL to discover the [[OpenID-Connect-Discovery]] provider
     * metadata.
     *
     * @generated from protobuf field: string open_id_connect_url = 2
     */
    openIdConnectUrl: string;
}
/**
 * @generated from protobuf message a2a.v1.OAuthFlows
 */
export interface OAuthFlows {
    /**
     * @generated from protobuf oneof: flow
     */
    flow: {
        oneofKind: "authorizationCode";
        /**
         * @generated from protobuf field: a2a.v1.AuthorizationCodeOAuthFlow authorization_code = 1
         */
        authorizationCode: AuthorizationCodeOAuthFlow;
    } | {
        oneofKind: "clientCredentials";
        /**
         * @generated from protobuf field: a2a.v1.ClientCredentialsOAuthFlow client_credentials = 2
         */
        clientCredentials: ClientCredentialsOAuthFlow;
    } | {
        oneofKind: "implicit";
        /**
         * @generated from protobuf field: a2a.v1.ImplicitOAuthFlow implicit = 3
         */
        implicit: ImplicitOAuthFlow;
    } | {
        oneofKind: "password";
        /**
         * @generated from protobuf field: a2a.v1.PasswordOAuthFlow password = 4
         */
        password: PasswordOAuthFlow;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message a2a.v1.AuthorizationCodeOAuthFlow
 */
export interface AuthorizationCodeOAuthFlow {
    /**
     * The authorization URL to be used for this flow. This MUST be in the
     * form of a URL. The OAuth2 standard requires the use of TLS
     *
     * @generated from protobuf field: string authorization_url = 1
     */
    authorizationUrl: string;
    /**
     * The token URL to be used for this flow. This MUST be in the form of a URL.
     * The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string token_url = 2
     */
    tokenUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens. This MUST be in the
     * form of a URL. The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string refresh_url = 3
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme. A map between the
     * scope name and a short description for it. The map MAY be empty.
     *
     * @generated from protobuf field: map<string, string> scopes = 4
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message a2a.v1.ClientCredentialsOAuthFlow
 */
export interface ClientCredentialsOAuthFlow {
    /**
     * The token URL to be used for this flow. This MUST be in the form of a URL.
     * The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string token_url = 1
     */
    tokenUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens. This MUST be in the
     * form of a URL. The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string refresh_url = 2
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme. A map between the
     * scope name and a short description for it. The map MAY be empty.
     *
     * @generated from protobuf field: map<string, string> scopes = 3
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message a2a.v1.ImplicitOAuthFlow
 */
export interface ImplicitOAuthFlow {
    /**
     * The authorization URL to be used for this flow. This MUST be in the
     * form of a URL. The OAuth2 standard requires the use of TLS
     *
     * @generated from protobuf field: string authorization_url = 1
     */
    authorizationUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens. This MUST be in the
     * form of a URL. The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string refresh_url = 2
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme. A map between the
     * scope name and a short description for it. The map MAY be empty.
     *
     * @generated from protobuf field: map<string, string> scopes = 3
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message a2a.v1.PasswordOAuthFlow
 */
export interface PasswordOAuthFlow {
    /**
     * The token URL to be used for this flow. This MUST be in the form of a URL.
     * The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string token_url = 1
     */
    tokenUrl: string;
    /**
     * The URL to be used for obtaining refresh tokens. This MUST be in the
     * form of a URL. The OAuth2 standard requires the use of TLS.
     *
     * @generated from protobuf field: string refresh_url = 2
     */
    refreshUrl: string;
    /**
     * The available scopes for the OAuth2 security scheme. A map between the
     * scope name and a short description for it. The map MAY be empty.
     *
     * @generated from protobuf field: map<string, string> scopes = 3
     */
    scopes: {
        [key: string]: string;
    };
}
/**
 * /////////// Request Messages ///////////
 *
 * @generated from protobuf message a2a.v1.SendMessageRequest
 */
export interface SendMessageRequest {
    /**
     * @generated from protobuf field: a2a.v1.Message request = 1
     */
    request?: Message;
    /**
     * @generated from protobuf field: a2a.v1.SendMessageConfiguration configuration = 2
     */
    configuration?: SendMessageConfiguration;
    /**
     * @generated from protobuf field: google.protobuf.Struct metadata = 3
     */
    metadata?: Struct;
}
/**
 * @generated from protobuf message a2a.v1.GetTaskRequest
 */
export interface GetTaskRequest {
    /**
     * name=tasks/{id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: int32 history_length = 2
     */
    historyLength: number;
}
/**
 * @generated from protobuf message a2a.v1.CancelTaskRequest
 */
export interface CancelTaskRequest {
    /**
     * name=tasks/{id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.GetTaskPushNotificationConfigRequest
 */
export interface GetTaskPushNotificationConfigRequest {
    /**
     * name=tasks/{id}/pushNotificationConfigs/{push_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.DeleteTaskPushNotificationConfigRequest
 */
export interface DeleteTaskPushNotificationConfigRequest {
    /**
     * name=tasks/{id}/pushNotificationConfigs/{push_id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.CreateTaskPushNotificationConfigRequest
 */
export interface CreateTaskPushNotificationConfigRequest {
    /**
     * The task resource for this config.
     * Format: tasks/{id}
     *
     * @generated from protobuf field: string parent = 1
     */
    parent: string;
    /**
     * @generated from protobuf field: string config_id = 2
     */
    configId: string;
    /**
     * @generated from protobuf field: a2a.v1.TaskPushNotificationConfig config = 3
     */
    config?: TaskPushNotificationConfig;
}
/**
 * @generated from protobuf message a2a.v1.TaskSubscriptionRequest
 */
export interface TaskSubscriptionRequest {
    /**
     * name=tasks/{id}
     *
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message a2a.v1.ListTaskPushNotificationConfigRequest
 */
export interface ListTaskPushNotificationConfigRequest {
    /**
     * parent=tasks/{id}
     *
     * @generated from protobuf field: string parent = 1
     */
    parent: string;
    /**
     * For AIP-158 these fields are present. Usually not used/needed.
     * The maximum number of configurations to return.
     * If unspecified, all configs will be returned.
     *
     * @generated from protobuf field: int32 page_size = 2
     */
    pageSize: number;
    /**
     * A page token received from a previous
     * ListTaskPushNotificationConfigRequest call.
     * Provide this to retrieve the subsequent page.
     * When paginating, all other parameters provided to
     * `ListTaskPushNotificationConfigRequest` must match the call that provided
     * the page token.
     *
     * @generated from protobuf field: string page_token = 3
     */
    pageToken: string;
}
/**
 * Empty. Added to fix linter violation.
 *
 * @generated from protobuf message a2a.v1.GetAgentCardRequest
 */
export interface GetAgentCardRequest {
}
/**
 * ////// Response Messages ///////////
 *
 * @generated from protobuf message a2a.v1.SendMessageResponse
 */
export interface SendMessageResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "task";
        /**
         * @generated from protobuf field: a2a.v1.Task task = 1
         */
        task: Task;
    } | {
        oneofKind: "msg";
        /**
         * @generated from protobuf field: a2a.v1.Message msg = 2 [json_name = "message"]
         */
        msg: Message;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The stream response for a message. The stream should be one of the following
 * sequences:
 * If the response is a message, the stream should contain one, and only one,
 * message and then close
 * If the response is a task lifecycle, the first response should be a Task
 * object followed by zero or more TaskStatusUpdateEvents and
 * TaskArtifactUpdateEvents. The stream should complete when the Task
 * if in an interrupted or terminal state. A stream that ends before these
 * conditions are met are
 *
 * @generated from protobuf message a2a.v1.StreamResponse
 */
export interface StreamResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "task";
        /**
         * @generated from protobuf field: a2a.v1.Task task = 1
         */
        task: Task;
    } | {
        oneofKind: "msg";
        /**
         * @generated from protobuf field: a2a.v1.Message msg = 2 [json_name = "message"]
         */
        msg: Message;
    } | {
        oneofKind: "statusUpdate";
        /**
         * @generated from protobuf field: a2a.v1.TaskStatusUpdateEvent status_update = 3
         */
        statusUpdate: TaskStatusUpdateEvent;
    } | {
        oneofKind: "artifactUpdate";
        /**
         * @generated from protobuf field: a2a.v1.TaskArtifactUpdateEvent artifact_update = 4
         */
        artifactUpdate: TaskArtifactUpdateEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message a2a.v1.ListTaskPushNotificationConfigResponse
 */
export interface ListTaskPushNotificationConfigResponse {
    /**
     * @generated from protobuf field: repeated a2a.v1.TaskPushNotificationConfig configs = 1
     */
    configs: TaskPushNotificationConfig[];
    /**
     * A token, which can be sent as `page_token` to retrieve the next page.
     * If this field is omitted, there are no subsequent pages.
     *
     * @generated from protobuf field: string next_page_token = 2
     */
    nextPageToken: string;
}
/**
 * The set of states a Task can be in.
 *
 * @generated from protobuf enum a2a.v1.TaskState
 */
export enum TaskState {
    /**
     * @generated from protobuf enum value: TASK_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Represents the status that acknowledges a task is created
     *
     * @generated from protobuf enum value: TASK_STATE_SUBMITTED = 1;
     */
    SUBMITTED = 1,
    /**
     * Represents the status that a task is actively being processed
     *
     * @generated from protobuf enum value: TASK_STATE_WORKING = 2;
     */
    WORKING = 2,
    /**
     * Represents the status a task is finished. This is a terminal state
     *
     * @generated from protobuf enum value: TASK_STATE_COMPLETED = 3;
     */
    COMPLETED = 3,
    /**
     * Represents the status a task is done but failed. This is a terminal state
     *
     * @generated from protobuf enum value: TASK_STATE_FAILED = 4;
     */
    FAILED = 4,
    /**
     * Represents the status a task was cancelled before it finished.
     * This is a terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_CANCELLED = 5;
     */
    CANCELLED = 5,
    /**
     * Represents the status that the task requires information to complete.
     * This is an interrupted state.
     *
     * @generated from protobuf enum value: TASK_STATE_INPUT_REQUIRED = 6;
     */
    INPUT_REQUIRED = 6,
    /**
     * Represents the status that the agent has decided to not perform the task.
     * This may be done during initial task creation or later once an agent
     * has determined it can't or won't proceed. This is a terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_REJECTED = 7;
     */
    REJECTED = 7,
    /**
     * Represents the state that some authentication is needed from the upstream
     * client. Authentication is expected to come out-of-band thus this is not
     * an interrupted or terminal state.
     *
     * @generated from protobuf enum value: TASK_STATE_AUTH_REQUIRED = 8;
     */
    AUTH_REQUIRED = 8
}
/**
 * @generated from protobuf enum a2a.v1.Role
 */
export enum Role {
    /**
     * @generated from protobuf enum value: ROLE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * USER role refers to communication from the client to the server.
     *
     * @generated from protobuf enum value: ROLE_USER = 1;
     */
    USER = 1,
    /**
     * AGENT role refers to communication from the server to the client.
     *
     * @generated from protobuf enum value: ROLE_AGENT = 2;
     */
    AGENT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageConfiguration$Type extends MessageType<SendMessageConfiguration> {
    constructor() {
        super("a2a.v1.SendMessageConfiguration", [
            { no: 1, name: "accepted_output_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "push_notification", kind: "message", T: () => PushNotificationConfig },
            { no: 3, name: "history_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "blocking", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SendMessageConfiguration>): SendMessageConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.acceptedOutputModes = [];
        message.historyLength = 0;
        message.blocking = false;
        if (value !== undefined)
            reflectionMergePartial<SendMessageConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageConfiguration): SendMessageConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string accepted_output_modes */ 1:
                    message.acceptedOutputModes.push(reader.string());
                    break;
                case /* a2a.v1.PushNotificationConfig push_notification */ 2:
                    message.pushNotification = PushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.pushNotification);
                    break;
                case /* int32 history_length */ 3:
                    message.historyLength = reader.int32();
                    break;
                case /* bool blocking */ 4:
                    message.blocking = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string accepted_output_modes = 1; */
        for (let i = 0; i < message.acceptedOutputModes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.acceptedOutputModes[i]);
        /* a2a.v1.PushNotificationConfig push_notification = 2; */
        if (message.pushNotification)
            PushNotificationConfig.internalBinaryWrite(message.pushNotification, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 history_length = 3; */
        if (message.historyLength !== 0)
            writer.tag(3, WireType.Varint).int32(message.historyLength);
        /* bool blocking = 4; */
        if (message.blocking !== false)
            writer.tag(4, WireType.Varint).bool(message.blocking);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SendMessageConfiguration
 */
export const SendMessageConfiguration = new SendMessageConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("a2a.v1.Task", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "message", T: () => TaskStatus },
            { no: 4, name: "artifacts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Artifact },
            { no: 5, name: "history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Message },
            { no: 6, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.contextId = "";
        message.artifacts = [];
        message.history = [];
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.TaskStatus status */ 3:
                    message.status = TaskStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* repeated a2a.v1.Artifact artifacts */ 4:
                    message.artifacts.push(Artifact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated a2a.v1.Message history */ 5:
                    message.history.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.TaskStatus status = 3; */
        if (message.status)
            TaskStatus.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated a2a.v1.Artifact artifacts = 4; */
        for (let i = 0; i < message.artifacts.length; i++)
            Artifact.internalBinaryWrite(message.artifacts[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated a2a.v1.Message history = 5; */
        for (let i = 0; i < message.history.length; i++)
            Message.internalBinaryWrite(message.history[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskStatus$Type extends MessageType<TaskStatus> {
    constructor() {
        super("a2a.v1.TaskStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["a2a.v1.TaskState", TaskState, "TASK_STATE_"] },
            { no: 2, name: "update", kind: "message", jsonName: "message", T: () => Message },
            { no: 3, name: "timestamp", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<TaskStatus>): TaskStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskStatus): TaskStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.TaskState state */ 1:
                    message.state = reader.int32();
                    break;
                case /* a2a.v1.Message update = 2 [json_name = "message"] */ 2:
                    message.update = Message.internalBinaryRead(reader, reader.uint32(), options, message.update);
                    break;
                case /* google.protobuf.Timestamp timestamp */ 3:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.TaskState state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* a2a.v1.Message update = 2 [json_name = "message"]; */
        if (message.update)
            Message.internalBinaryWrite(message.update, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp timestamp = 3; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskStatus
 */
export const TaskStatus = new TaskStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Part$Type extends MessageType<Part> {
    constructor() {
        super("a2a.v1.Part", [
            { no: 1, name: "text", kind: "scalar", oneof: "part", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file", kind: "message", oneof: "part", T: () => FilePart },
            { no: 3, name: "data", kind: "message", oneof: "part", T: () => DataPart }
        ]);
    }
    create(value?: PartialMessage<Part>): Part {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.part = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Part>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Part): Part {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.part = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* a2a.v1.FilePart file */ 2:
                    message.part = {
                        oneofKind: "file",
                        file: FilePart.internalBinaryRead(reader, reader.uint32(), options, (message.part as any).file)
                    };
                    break;
                case /* a2a.v1.DataPart data */ 3:
                    message.part = {
                        oneofKind: "data",
                        data: DataPart.internalBinaryRead(reader, reader.uint32(), options, (message.part as any).data)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Part, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.part.oneofKind === "text")
            writer.tag(1, WireType.LengthDelimited).string(message.part.text);
        /* a2a.v1.FilePart file = 2; */
        if (message.part.oneofKind === "file")
            FilePart.internalBinaryWrite(message.part.file, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.DataPart data = 3; */
        if (message.part.oneofKind === "data")
            DataPart.internalBinaryWrite(message.part.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Part
 */
export const Part = new Part$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilePart$Type extends MessageType<FilePart> {
    constructor() {
        super("a2a.v1.FilePart", [
            { no: 1, name: "file_with_uri", kind: "scalar", oneof: "file", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "file_with_bytes", kind: "scalar", oneof: "file", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "mime_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FilePart>): FilePart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.file = { oneofKind: undefined };
        message.mimeType = "";
        if (value !== undefined)
            reflectionMergePartial<FilePart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilePart): FilePart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string file_with_uri */ 1:
                    message.file = {
                        oneofKind: "fileWithUri",
                        fileWithUri: reader.string()
                    };
                    break;
                case /* bytes file_with_bytes */ 2:
                    message.file = {
                        oneofKind: "fileWithBytes",
                        fileWithBytes: reader.bytes()
                    };
                    break;
                case /* string mime_type */ 3:
                    message.mimeType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilePart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string file_with_uri = 1; */
        if (message.file.oneofKind === "fileWithUri")
            writer.tag(1, WireType.LengthDelimited).string(message.file.fileWithUri);
        /* bytes file_with_bytes = 2; */
        if (message.file.oneofKind === "fileWithBytes")
            writer.tag(2, WireType.LengthDelimited).bytes(message.file.fileWithBytes);
        /* string mime_type = 3; */
        if (message.mimeType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.mimeType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.FilePart
 */
export const FilePart = new FilePart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataPart$Type extends MessageType<DataPart> {
    constructor() {
        super("a2a.v1.DataPart", [
            { no: 1, name: "data", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<DataPart>): DataPart {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DataPart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataPart): DataPart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct data */ 1:
                    message.data = Struct.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataPart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct data = 1; */
        if (message.data)
            Struct.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.DataPart
 */
export const DataPart = new DataPart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("a2a.v1.Message", [
            { no: 1, name: "message_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "role", kind: "enum", T: () => ["a2a.v1.Role", Role, "ROLE_"] },
            { no: 5, name: "content", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Part },
            { no: 6, name: "metadata", kind: "message", T: () => Struct },
            { no: 7, name: "extensions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = "";
        message.contextId = "";
        message.taskId = "";
        message.role = 0;
        message.content = [];
        message.extensions = [];
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_id */ 1:
                    message.messageId = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* string task_id */ 3:
                    message.taskId = reader.string();
                    break;
                case /* a2a.v1.Role role */ 4:
                    message.role = reader.int32();
                    break;
                case /* repeated a2a.v1.Part content */ 5:
                    message.content.push(Part.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* repeated string extensions */ 7:
                    message.extensions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_id = 1; */
        if (message.messageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageId);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* string task_id = 3; */
        if (message.taskId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.taskId);
        /* a2a.v1.Role role = 4; */
        if (message.role !== 0)
            writer.tag(4, WireType.Varint).int32(message.role);
        /* repeated a2a.v1.Part content = 5; */
        for (let i = 0; i < message.content.length; i++)
            Part.internalBinaryWrite(message.content[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string extensions = 7; */
        for (let i = 0; i < message.extensions.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.extensions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Artifact$Type extends MessageType<Artifact> {
    constructor() {
        super("a2a.v1.Artifact", [
            { no: 1, name: "artifact_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "parts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Part },
            { no: 6, name: "metadata", kind: "message", T: () => Struct },
            { no: 7, name: "extensions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Artifact>): Artifact {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.artifactId = "";
        message.name = "";
        message.description = "";
        message.parts = [];
        message.extensions = [];
        if (value !== undefined)
            reflectionMergePartial<Artifact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Artifact): Artifact {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string artifact_id */ 1:
                    message.artifactId = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* repeated a2a.v1.Part parts */ 5:
                    message.parts.push(Part.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* repeated string extensions */ 7:
                    message.extensions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Artifact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string artifact_id = 1; */
        if (message.artifactId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.artifactId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* repeated a2a.v1.Part parts = 5; */
        for (let i = 0; i < message.parts.length; i++)
            Part.internalBinaryWrite(message.parts[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string extensions = 7; */
        for (let i = 0; i < message.extensions.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.extensions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Artifact
 */
export const Artifact = new Artifact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskStatusUpdateEvent$Type extends MessageType<TaskStatusUpdateEvent> {
    constructor() {
        super("a2a.v1.TaskStatusUpdateEvent", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "message", T: () => TaskStatus },
            { no: 4, name: "final", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<TaskStatusUpdateEvent>): TaskStatusUpdateEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = "";
        message.contextId = "";
        message.final = false;
        if (value !== undefined)
            reflectionMergePartial<TaskStatusUpdateEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskStatusUpdateEvent): TaskStatusUpdateEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.TaskStatus status */ 3:
                    message.status = TaskStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* bool final */ 4:
                    message.final = reader.bool();
                    break;
                case /* google.protobuf.Struct metadata */ 5:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskStatusUpdateEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.TaskStatus status = 3; */
        if (message.status)
            TaskStatus.internalBinaryWrite(message.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool final = 4; */
        if (message.final !== false)
            writer.tag(4, WireType.Varint).bool(message.final);
        /* google.protobuf.Struct metadata = 5; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskStatusUpdateEvent
 */
export const TaskStatusUpdateEvent = new TaskStatusUpdateEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskArtifactUpdateEvent$Type extends MessageType<TaskArtifactUpdateEvent> {
    constructor() {
        super("a2a.v1.TaskArtifactUpdateEvent", [
            { no: 1, name: "task_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "context_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "artifact", kind: "message", T: () => Artifact },
            { no: 4, name: "append", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "last_chunk", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<TaskArtifactUpdateEvent>): TaskArtifactUpdateEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = "";
        message.contextId = "";
        message.append = false;
        message.lastChunk = false;
        if (value !== undefined)
            reflectionMergePartial<TaskArtifactUpdateEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskArtifactUpdateEvent): TaskArtifactUpdateEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.taskId = reader.string();
                    break;
                case /* string context_id */ 2:
                    message.contextId = reader.string();
                    break;
                case /* a2a.v1.Artifact artifact */ 3:
                    message.artifact = Artifact.internalBinaryRead(reader, reader.uint32(), options, message.artifact);
                    break;
                case /* bool append */ 4:
                    message.append = reader.bool();
                    break;
                case /* bool last_chunk */ 5:
                    message.lastChunk = reader.bool();
                    break;
                case /* google.protobuf.Struct metadata */ 6:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskArtifactUpdateEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.taskId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.taskId);
        /* string context_id = 2; */
        if (message.contextId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contextId);
        /* a2a.v1.Artifact artifact = 3; */
        if (message.artifact)
            Artifact.internalBinaryWrite(message.artifact, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool append = 4; */
        if (message.append !== false)
            writer.tag(4, WireType.Varint).bool(message.append);
        /* bool last_chunk = 5; */
        if (message.lastChunk !== false)
            writer.tag(5, WireType.Varint).bool(message.lastChunk);
        /* google.protobuf.Struct metadata = 6; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskArtifactUpdateEvent
 */
export const TaskArtifactUpdateEvent = new TaskArtifactUpdateEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushNotificationConfig$Type extends MessageType<PushNotificationConfig> {
    constructor() {
        super("a2a.v1.PushNotificationConfig", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "authentication", kind: "message", T: () => AuthenticationInfo }
        ]);
    }
    create(value?: PartialMessage<PushNotificationConfig>): PushNotificationConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.url = "";
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<PushNotificationConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushNotificationConfig): PushNotificationConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                case /* a2a.v1.AuthenticationInfo authentication */ 4:
                    message.authentication = AuthenticationInfo.internalBinaryRead(reader, reader.uint32(), options, message.authentication);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushNotificationConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* a2a.v1.AuthenticationInfo authentication = 4; */
        if (message.authentication)
            AuthenticationInfo.internalBinaryWrite(message.authentication, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.PushNotificationConfig
 */
export const PushNotificationConfig = new PushNotificationConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthenticationInfo$Type extends MessageType<AuthenticationInfo> {
    constructor() {
        super("a2a.v1.AuthenticationInfo", [
            { no: 1, name: "schemes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "credentials", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AuthenticationInfo>): AuthenticationInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemes = [];
        message.credentials = "";
        if (value !== undefined)
            reflectionMergePartial<AuthenticationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthenticationInfo): AuthenticationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string schemes */ 1:
                    message.schemes.push(reader.string());
                    break;
                case /* string credentials */ 2:
                    message.credentials = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthenticationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string schemes = 1; */
        for (let i = 0; i < message.schemes.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.schemes[i]);
        /* string credentials = 2; */
        if (message.credentials !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.credentials);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AuthenticationInfo
 */
export const AuthenticationInfo = new AuthenticationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentInterface$Type extends MessageType<AgentInterface> {
    constructor() {
        super("a2a.v1.AgentInterface", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transport", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AgentInterface>): AgentInterface {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.transport = "";
        if (value !== undefined)
            reflectionMergePartial<AgentInterface>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentInterface): AgentInterface {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string transport */ 2:
                    message.transport = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentInterface, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string transport = 2; */
        if (message.transport !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.transport);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentInterface
 */
export const AgentInterface = new AgentInterface$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentCard$Type extends MessageType<AgentCard> {
    constructor() {
        super("a2a.v1.AgentCard", [
            { no: 16, name: "protocol_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "preferred_transport", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "additional_interfaces", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentInterface },
            { no: 4, name: "provider", kind: "message", T: () => AgentProvider },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "documentation_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "capabilities", kind: "message", T: () => AgentCapabilities },
            { no: 8, name: "security_schemes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SecurityScheme } },
            { no: 9, name: "security", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Security },
            { no: 10, name: "default_input_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "default_output_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "skills", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentSkill },
            { no: 13, name: "supports_authenticated_extended_card", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AgentCard>): AgentCard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocolVersion = "";
        message.name = "";
        message.description = "";
        message.url = "";
        message.preferredTransport = "";
        message.additionalInterfaces = [];
        message.version = "";
        message.documentationUrl = "";
        message.securitySchemes = {};
        message.security = [];
        message.defaultInputModes = [];
        message.defaultOutputModes = [];
        message.skills = [];
        message.supportsAuthenticatedExtendedCard = false;
        if (value !== undefined)
            reflectionMergePartial<AgentCard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentCard): AgentCard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string protocol_version */ 16:
                    message.protocolVersion = reader.string();
                    break;
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string url */ 3:
                    message.url = reader.string();
                    break;
                case /* string preferred_transport */ 14:
                    message.preferredTransport = reader.string();
                    break;
                case /* repeated a2a.v1.AgentInterface additional_interfaces */ 15:
                    message.additionalInterfaces.push(AgentInterface.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* a2a.v1.AgentProvider provider */ 4:
                    message.provider = AgentProvider.internalBinaryRead(reader, reader.uint32(), options, message.provider);
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* string documentation_url */ 6:
                    message.documentationUrl = reader.string();
                    break;
                case /* a2a.v1.AgentCapabilities capabilities */ 7:
                    message.capabilities = AgentCapabilities.internalBinaryRead(reader, reader.uint32(), options, message.capabilities);
                    break;
                case /* map<string, a2a.v1.SecurityScheme> security_schemes */ 8:
                    this.binaryReadMap8(message.securitySchemes, reader, options);
                    break;
                case /* repeated a2a.v1.Security security */ 9:
                    message.security.push(Security.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string default_input_modes */ 10:
                    message.defaultInputModes.push(reader.string());
                    break;
                case /* repeated string default_output_modes */ 11:
                    message.defaultOutputModes.push(reader.string());
                    break;
                case /* repeated a2a.v1.AgentSkill skills */ 12:
                    message.skills.push(AgentSkill.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool supports_authenticated_extended_card */ 13:
                    message.supportsAuthenticatedExtendedCard = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: AgentCard["securitySchemes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AgentCard["securitySchemes"] | undefined, val: AgentCard["securitySchemes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SecurityScheme.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.AgentCard.security_schemes");
            }
        }
        map[key ?? ""] = val ?? SecurityScheme.create();
    }
    internalBinaryWrite(message: AgentCard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string url = 3; */
        if (message.url !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.url);
        /* a2a.v1.AgentProvider provider = 4; */
        if (message.provider)
            AgentProvider.internalBinaryWrite(message.provider, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* string documentation_url = 6; */
        if (message.documentationUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.documentationUrl);
        /* a2a.v1.AgentCapabilities capabilities = 7; */
        if (message.capabilities)
            AgentCapabilities.internalBinaryWrite(message.capabilities, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* map<string, a2a.v1.SecurityScheme> security_schemes = 8; */
        for (let k of globalThis.Object.keys(message.securitySchemes)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SecurityScheme.internalBinaryWrite(message.securitySchemes[k], writer, options);
            writer.join().join();
        }
        /* repeated a2a.v1.Security security = 9; */
        for (let i = 0; i < message.security.length; i++)
            Security.internalBinaryWrite(message.security[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string default_input_modes = 10; */
        for (let i = 0; i < message.defaultInputModes.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.defaultInputModes[i]);
        /* repeated string default_output_modes = 11; */
        for (let i = 0; i < message.defaultOutputModes.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.defaultOutputModes[i]);
        /* repeated a2a.v1.AgentSkill skills = 12; */
        for (let i = 0; i < message.skills.length; i++)
            AgentSkill.internalBinaryWrite(message.skills[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool supports_authenticated_extended_card = 13; */
        if (message.supportsAuthenticatedExtendedCard !== false)
            writer.tag(13, WireType.Varint).bool(message.supportsAuthenticatedExtendedCard);
        /* string preferred_transport = 14; */
        if (message.preferredTransport !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.preferredTransport);
        /* repeated a2a.v1.AgentInterface additional_interfaces = 15; */
        for (let i = 0; i < message.additionalInterfaces.length; i++)
            AgentInterface.internalBinaryWrite(message.additionalInterfaces[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* string protocol_version = 16; */
        if (message.protocolVersion !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.protocolVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentCard
 */
export const AgentCard = new AgentCard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentProvider$Type extends MessageType<AgentProvider> {
    constructor() {
        super("a2a.v1.AgentProvider", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "organization", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AgentProvider>): AgentProvider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        message.organization = "";
        if (value !== undefined)
            reflectionMergePartial<AgentProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentProvider): AgentProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                case /* string organization */ 2:
                    message.organization = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        /* string organization = 2; */
        if (message.organization !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.organization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentProvider
 */
export const AgentProvider = new AgentProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentCapabilities$Type extends MessageType<AgentCapabilities> {
    constructor() {
        super("a2a.v1.AgentCapabilities", [
            { no: 1, name: "streaming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "push_notifications", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "extensions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AgentExtension }
        ]);
    }
    create(value?: PartialMessage<AgentCapabilities>): AgentCapabilities {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streaming = false;
        message.pushNotifications = false;
        message.extensions = [];
        if (value !== undefined)
            reflectionMergePartial<AgentCapabilities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentCapabilities): AgentCapabilities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool streaming */ 1:
                    message.streaming = reader.bool();
                    break;
                case /* bool push_notifications */ 2:
                    message.pushNotifications = reader.bool();
                    break;
                case /* repeated a2a.v1.AgentExtension extensions */ 3:
                    message.extensions.push(AgentExtension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentCapabilities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool streaming = 1; */
        if (message.streaming !== false)
            writer.tag(1, WireType.Varint).bool(message.streaming);
        /* bool push_notifications = 2; */
        if (message.pushNotifications !== false)
            writer.tag(2, WireType.Varint).bool(message.pushNotifications);
        /* repeated a2a.v1.AgentExtension extensions = 3; */
        for (let i = 0; i < message.extensions.length; i++)
            AgentExtension.internalBinaryWrite(message.extensions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentCapabilities
 */
export const AgentCapabilities = new AgentCapabilities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentExtension$Type extends MessageType<AgentExtension> {
    constructor() {
        super("a2a.v1.AgentExtension", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "params", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<AgentExtension>): AgentExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        message.description = "";
        message.required = false;
        if (value !== undefined)
            reflectionMergePartial<AgentExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentExtension): AgentExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* bool required */ 3:
                    message.required = reader.bool();
                    break;
                case /* google.protobuf.Struct params */ 4:
                    message.params = Struct.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* bool required = 3; */
        if (message.required !== false)
            writer.tag(3, WireType.Varint).bool(message.required);
        /* google.protobuf.Struct params = 4; */
        if (message.params)
            Struct.internalBinaryWrite(message.params, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentExtension
 */
export const AgentExtension = new AgentExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentSkill$Type extends MessageType<AgentSkill> {
    constructor() {
        super("a2a.v1.AgentSkill", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "examples", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "input_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "output_modes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AgentSkill>): AgentSkill {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.description = "";
        message.tags = [];
        message.examples = [];
        message.inputModes = [];
        message.outputModes = [];
        if (value !== undefined)
            reflectionMergePartial<AgentSkill>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgentSkill): AgentSkill {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* repeated string tags */ 4:
                    message.tags.push(reader.string());
                    break;
                case /* repeated string examples */ 5:
                    message.examples.push(reader.string());
                    break;
                case /* repeated string input_modes */ 6:
                    message.inputModes.push(reader.string());
                    break;
                case /* repeated string output_modes */ 7:
                    message.outputModes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgentSkill, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* repeated string tags = 4; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.tags[i]);
        /* repeated string examples = 5; */
        for (let i = 0; i < message.examples.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.examples[i]);
        /* repeated string input_modes = 6; */
        for (let i = 0; i < message.inputModes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.inputModes[i]);
        /* repeated string output_modes = 7; */
        for (let i = 0; i < message.outputModes.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.outputModes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AgentSkill
 */
export const AgentSkill = new AgentSkill$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskPushNotificationConfig$Type extends MessageType<TaskPushNotificationConfig> {
    constructor() {
        super("a2a.v1.TaskPushNotificationConfig", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "push_notification_config", kind: "message", T: () => PushNotificationConfig }
        ]);
    }
    create(value?: PartialMessage<TaskPushNotificationConfig>): TaskPushNotificationConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<TaskPushNotificationConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskPushNotificationConfig): TaskPushNotificationConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* a2a.v1.PushNotificationConfig push_notification_config */ 2:
                    message.pushNotificationConfig = PushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.pushNotificationConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskPushNotificationConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* a2a.v1.PushNotificationConfig push_notification_config = 2; */
        if (message.pushNotificationConfig)
            PushNotificationConfig.internalBinaryWrite(message.pushNotificationConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskPushNotificationConfig
 */
export const TaskPushNotificationConfig = new TaskPushNotificationConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringList$Type extends MessageType<StringList> {
    constructor() {
        super("a2a.v1.StringList", [
            { no: 1, name: "list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StringList>): StringList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<StringList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringList): StringList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string list */ 1:
                    message.list.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string list = 1; */
        for (let i = 0; i < message.list.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.list[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.StringList
 */
export const StringList = new StringList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Security$Type extends MessageType<Security> {
    constructor() {
        super("a2a.v1.Security", [
            { no: 1, name: "schemes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => StringList } }
        ]);
    }
    create(value?: PartialMessage<Security>): Security {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemes = {};
        if (value !== undefined)
            reflectionMergePartial<Security>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Security): Security {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, a2a.v1.StringList> schemes */ 1:
                    this.binaryReadMap1(message.schemes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Security["schemes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Security["schemes"] | undefined, val: Security["schemes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = StringList.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.Security.schemes");
            }
        }
        map[key ?? ""] = val ?? StringList.create();
    }
    internalBinaryWrite(message: Security, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, a2a.v1.StringList> schemes = 1; */
        for (let k of globalThis.Object.keys(message.schemes)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            StringList.internalBinaryWrite(message.schemes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.Security
 */
export const Security = new Security$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecurityScheme$Type extends MessageType<SecurityScheme> {
    constructor() {
        super("a2a.v1.SecurityScheme", [
            { no: 1, name: "api_key_security_scheme", kind: "message", oneof: "scheme", T: () => APIKeySecurityScheme },
            { no: 2, name: "http_auth_security_scheme", kind: "message", oneof: "scheme", T: () => HTTPAuthSecurityScheme },
            { no: 3, name: "oauth2_security_scheme", kind: "message", oneof: "scheme", T: () => OAuth2SecurityScheme },
            { no: 4, name: "open_id_connect_security_scheme", kind: "message", oneof: "scheme", T: () => OpenIdConnectSecurityScheme }
        ]);
    }
    create(value?: PartialMessage<SecurityScheme>): SecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scheme = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecurityScheme): SecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.APIKeySecurityScheme api_key_security_scheme */ 1:
                    message.scheme = {
                        oneofKind: "apiKeySecurityScheme",
                        apiKeySecurityScheme: APIKeySecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).apiKeySecurityScheme)
                    };
                    break;
                case /* a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme */ 2:
                    message.scheme = {
                        oneofKind: "httpAuthSecurityScheme",
                        httpAuthSecurityScheme: HTTPAuthSecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).httpAuthSecurityScheme)
                    };
                    break;
                case /* a2a.v1.OAuth2SecurityScheme oauth2_security_scheme */ 3:
                    message.scheme = {
                        oneofKind: "oauth2SecurityScheme",
                        oauth2SecurityScheme: OAuth2SecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).oauth2SecurityScheme)
                    };
                    break;
                case /* a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme */ 4:
                    message.scheme = {
                        oneofKind: "openIdConnectSecurityScheme",
                        openIdConnectSecurityScheme: OpenIdConnectSecurityScheme.internalBinaryRead(reader, reader.uint32(), options, (message.scheme as any).openIdConnectSecurityScheme)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.APIKeySecurityScheme api_key_security_scheme = 1; */
        if (message.scheme.oneofKind === "apiKeySecurityScheme")
            APIKeySecurityScheme.internalBinaryWrite(message.scheme.apiKeySecurityScheme, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.HTTPAuthSecurityScheme http_auth_security_scheme = 2; */
        if (message.scheme.oneofKind === "httpAuthSecurityScheme")
            HTTPAuthSecurityScheme.internalBinaryWrite(message.scheme.httpAuthSecurityScheme, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.OAuth2SecurityScheme oauth2_security_scheme = 3; */
        if (message.scheme.oneofKind === "oauth2SecurityScheme")
            OAuth2SecurityScheme.internalBinaryWrite(message.scheme.oauth2SecurityScheme, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.OpenIdConnectSecurityScheme open_id_connect_security_scheme = 4; */
        if (message.scheme.oneofKind === "openIdConnectSecurityScheme")
            OpenIdConnectSecurityScheme.internalBinaryWrite(message.scheme.openIdConnectSecurityScheme, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SecurityScheme
 */
export const SecurityScheme = new SecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class APIKeySecurityScheme$Type extends MessageType<APIKeySecurityScheme> {
    constructor() {
        super("a2a.v1.APIKeySecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<APIKeySecurityScheme>): APIKeySecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.location = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<APIKeySecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: APIKeySecurityScheme): APIKeySecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string location */ 2:
                    message.location = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: APIKeySecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string location = 2; */
        if (message.location !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.location);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.APIKeySecurityScheme
 */
export const APIKeySecurityScheme = new APIKeySecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPAuthSecurityScheme$Type extends MessageType<HTTPAuthSecurityScheme> {
    constructor() {
        super("a2a.v1.HTTPAuthSecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scheme", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bearer_format", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HTTPAuthSecurityScheme>): HTTPAuthSecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.scheme = "";
        message.bearerFormat = "";
        if (value !== undefined)
            reflectionMergePartial<HTTPAuthSecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPAuthSecurityScheme): HTTPAuthSecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string scheme */ 2:
                    message.scheme = reader.string();
                    break;
                case /* string bearer_format */ 3:
                    message.bearerFormat = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPAuthSecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string scheme = 2; */
        if (message.scheme !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.scheme);
        /* string bearer_format = 3; */
        if (message.bearerFormat !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.bearerFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.HTTPAuthSecurityScheme
 */
export const HTTPAuthSecurityScheme = new HTTPAuthSecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OAuth2SecurityScheme$Type extends MessageType<OAuth2SecurityScheme> {
    constructor() {
        super("a2a.v1.OAuth2SecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "flows", kind: "message", T: () => OAuthFlows }
        ]);
    }
    create(value?: PartialMessage<OAuth2SecurityScheme>): OAuth2SecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        if (value !== undefined)
            reflectionMergePartial<OAuth2SecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OAuth2SecurityScheme): OAuth2SecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* a2a.v1.OAuthFlows flows */ 2:
                    message.flows = OAuthFlows.internalBinaryRead(reader, reader.uint32(), options, message.flows);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OAuth2SecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* a2a.v1.OAuthFlows flows = 2; */
        if (message.flows)
            OAuthFlows.internalBinaryWrite(message.flows, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.OAuth2SecurityScheme
 */
export const OAuth2SecurityScheme = new OAuth2SecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenIdConnectSecurityScheme$Type extends MessageType<OpenIdConnectSecurityScheme> {
    constructor() {
        super("a2a.v1.OpenIdConnectSecurityScheme", [
            { no: 1, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "open_id_connect_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OpenIdConnectSecurityScheme>): OpenIdConnectSecurityScheme {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.description = "";
        message.openIdConnectUrl = "";
        if (value !== undefined)
            reflectionMergePartial<OpenIdConnectSecurityScheme>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenIdConnectSecurityScheme): OpenIdConnectSecurityScheme {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string description */ 1:
                    message.description = reader.string();
                    break;
                case /* string open_id_connect_url */ 2:
                    message.openIdConnectUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenIdConnectSecurityScheme, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string description = 1; */
        if (message.description !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.description);
        /* string open_id_connect_url = 2; */
        if (message.openIdConnectUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.openIdConnectUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.OpenIdConnectSecurityScheme
 */
export const OpenIdConnectSecurityScheme = new OpenIdConnectSecurityScheme$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OAuthFlows$Type extends MessageType<OAuthFlows> {
    constructor() {
        super("a2a.v1.OAuthFlows", [
            { no: 1, name: "authorization_code", kind: "message", oneof: "flow", T: () => AuthorizationCodeOAuthFlow },
            { no: 2, name: "client_credentials", kind: "message", oneof: "flow", T: () => ClientCredentialsOAuthFlow },
            { no: 3, name: "implicit", kind: "message", oneof: "flow", T: () => ImplicitOAuthFlow },
            { no: 4, name: "password", kind: "message", oneof: "flow", T: () => PasswordOAuthFlow }
        ]);
    }
    create(value?: PartialMessage<OAuthFlows>): OAuthFlows {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flow = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OAuthFlows>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OAuthFlows): OAuthFlows {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.AuthorizationCodeOAuthFlow authorization_code */ 1:
                    message.flow = {
                        oneofKind: "authorizationCode",
                        authorizationCode: AuthorizationCodeOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).authorizationCode)
                    };
                    break;
                case /* a2a.v1.ClientCredentialsOAuthFlow client_credentials */ 2:
                    message.flow = {
                        oneofKind: "clientCredentials",
                        clientCredentials: ClientCredentialsOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).clientCredentials)
                    };
                    break;
                case /* a2a.v1.ImplicitOAuthFlow implicit */ 3:
                    message.flow = {
                        oneofKind: "implicit",
                        implicit: ImplicitOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).implicit)
                    };
                    break;
                case /* a2a.v1.PasswordOAuthFlow password */ 4:
                    message.flow = {
                        oneofKind: "password",
                        password: PasswordOAuthFlow.internalBinaryRead(reader, reader.uint32(), options, (message.flow as any).password)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OAuthFlows, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.AuthorizationCodeOAuthFlow authorization_code = 1; */
        if (message.flow.oneofKind === "authorizationCode")
            AuthorizationCodeOAuthFlow.internalBinaryWrite(message.flow.authorizationCode, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.ClientCredentialsOAuthFlow client_credentials = 2; */
        if (message.flow.oneofKind === "clientCredentials")
            ClientCredentialsOAuthFlow.internalBinaryWrite(message.flow.clientCredentials, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.ImplicitOAuthFlow implicit = 3; */
        if (message.flow.oneofKind === "implicit")
            ImplicitOAuthFlow.internalBinaryWrite(message.flow.implicit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.PasswordOAuthFlow password = 4; */
        if (message.flow.oneofKind === "password")
            PasswordOAuthFlow.internalBinaryWrite(message.flow.password, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.OAuthFlows
 */
export const OAuthFlows = new OAuthFlows$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationCodeOAuthFlow$Type extends MessageType<AuthorizationCodeOAuthFlow> {
    constructor() {
        super("a2a.v1.AuthorizationCodeOAuthFlow", [
            { no: 1, name: "authorization_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<AuthorizationCodeOAuthFlow>): AuthorizationCodeOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizationUrl = "";
        message.tokenUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<AuthorizationCodeOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationCodeOAuthFlow): AuthorizationCodeOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authorization_url */ 1:
                    message.authorizationUrl = reader.string();
                    break;
                case /* string token_url */ 2:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 3:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 4:
                    this.binaryReadMap4(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: AuthorizationCodeOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AuthorizationCodeOAuthFlow["scopes"] | undefined, val: AuthorizationCodeOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.AuthorizationCodeOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AuthorizationCodeOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authorization_url = 1; */
        if (message.authorizationUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorizationUrl);
        /* string token_url = 2; */
        if (message.tokenUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 3; */
        if (message.refreshUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 4; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.AuthorizationCodeOAuthFlow
 */
export const AuthorizationCodeOAuthFlow = new AuthorizationCodeOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientCredentialsOAuthFlow$Type extends MessageType<ClientCredentialsOAuthFlow> {
    constructor() {
        super("a2a.v1.ClientCredentialsOAuthFlow", [
            { no: 1, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ClientCredentialsOAuthFlow>): ClientCredentialsOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tokenUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<ClientCredentialsOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientCredentialsOAuthFlow): ClientCredentialsOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token_url */ 1:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 2:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 3:
                    this.binaryReadMap3(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ClientCredentialsOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ClientCredentialsOAuthFlow["scopes"] | undefined, val: ClientCredentialsOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.ClientCredentialsOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ClientCredentialsOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token_url = 1; */
        if (message.tokenUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 2; */
        if (message.refreshUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 3; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ClientCredentialsOAuthFlow
 */
export const ClientCredentialsOAuthFlow = new ClientCredentialsOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImplicitOAuthFlow$Type extends MessageType<ImplicitOAuthFlow> {
    constructor() {
        super("a2a.v1.ImplicitOAuthFlow", [
            { no: 1, name: "authorization_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ImplicitOAuthFlow>): ImplicitOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authorizationUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<ImplicitOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImplicitOAuthFlow): ImplicitOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authorization_url */ 1:
                    message.authorizationUrl = reader.string();
                    break;
                case /* string refresh_url */ 2:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 3:
                    this.binaryReadMap3(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ImplicitOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ImplicitOAuthFlow["scopes"] | undefined, val: ImplicitOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.ImplicitOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ImplicitOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authorization_url = 1; */
        if (message.authorizationUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorizationUrl);
        /* string refresh_url = 2; */
        if (message.refreshUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 3; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ImplicitOAuthFlow
 */
export const ImplicitOAuthFlow = new ImplicitOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasswordOAuthFlow$Type extends MessageType<PasswordOAuthFlow> {
    constructor() {
        super("a2a.v1.PasswordOAuthFlow", [
            { no: 1, name: "token_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "refresh_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scopes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<PasswordOAuthFlow>): PasswordOAuthFlow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tokenUrl = "";
        message.refreshUrl = "";
        message.scopes = {};
        if (value !== undefined)
            reflectionMergePartial<PasswordOAuthFlow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PasswordOAuthFlow): PasswordOAuthFlow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token_url */ 1:
                    message.tokenUrl = reader.string();
                    break;
                case /* string refresh_url */ 2:
                    message.refreshUrl = reader.string();
                    break;
                case /* map<string, string> scopes */ 3:
                    this.binaryReadMap3(message.scopes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: PasswordOAuthFlow["scopes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PasswordOAuthFlow["scopes"] | undefined, val: PasswordOAuthFlow["scopes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for a2a.v1.PasswordOAuthFlow.scopes");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: PasswordOAuthFlow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token_url = 1; */
        if (message.tokenUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tokenUrl);
        /* string refresh_url = 2; */
        if (message.refreshUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.refreshUrl);
        /* map<string, string> scopes = 3; */
        for (let k of globalThis.Object.keys(message.scopes))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.scopes[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.PasswordOAuthFlow
 */
export const PasswordOAuthFlow = new PasswordOAuthFlow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageRequest$Type extends MessageType<SendMessageRequest> {
    constructor() {
        super("a2a.v1.SendMessageRequest", [
            { no: 1, name: "request", kind: "message", T: () => Message, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "configuration", kind: "message", T: () => SendMessageConfiguration },
            { no: 3, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<SendMessageRequest>): SendMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SendMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageRequest): SendMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.Message request */ 1:
                    message.request = Message.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* a2a.v1.SendMessageConfiguration configuration */ 2:
                    message.configuration = SendMessageConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                case /* google.protobuf.Struct metadata */ 3:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.Message request = 1; */
        if (message.request)
            Message.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.SendMessageConfiguration configuration = 2; */
        if (message.configuration)
            SendMessageConfiguration.internalBinaryWrite(message.configuration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 3; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SendMessageRequest
 */
export const SendMessageRequest = new SendMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTaskRequest$Type extends MessageType<GetTaskRequest> {
    constructor() {
        super("a2a.v1.GetTaskRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "history_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetTaskRequest>): GetTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.historyLength = 0;
        if (value !== undefined)
            reflectionMergePartial<GetTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTaskRequest): GetTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 history_length */ 2:
                    message.historyLength = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 history_length = 2; */
        if (message.historyLength !== 0)
            writer.tag(2, WireType.Varint).int32(message.historyLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.GetTaskRequest
 */
export const GetTaskRequest = new GetTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelTaskRequest$Type extends MessageType<CancelTaskRequest> {
    constructor() {
        super("a2a.v1.CancelTaskRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CancelTaskRequest>): CancelTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CancelTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelTaskRequest): CancelTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.CancelTaskRequest
 */
export const CancelTaskRequest = new CancelTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTaskPushNotificationConfigRequest$Type extends MessageType<GetTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.GetTaskPushNotificationConfigRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetTaskPushNotificationConfigRequest>): GetTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<GetTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTaskPushNotificationConfigRequest): GetTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.GetTaskPushNotificationConfigRequest
 */
export const GetTaskPushNotificationConfigRequest = new GetTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTaskPushNotificationConfigRequest$Type extends MessageType<DeleteTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.DeleteTaskPushNotificationConfigRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTaskPushNotificationConfigRequest>): DeleteTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTaskPushNotificationConfigRequest): DeleteTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.DeleteTaskPushNotificationConfigRequest
 */
export const DeleteTaskPushNotificationConfigRequest = new DeleteTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTaskPushNotificationConfigRequest$Type extends MessageType<CreateTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.CreateTaskPushNotificationConfigRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "config_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "config", kind: "message", T: () => TaskPushNotificationConfig, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value?: PartialMessage<CreateTaskPushNotificationConfigRequest>): CreateTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parent = "";
        message.configId = "";
        if (value !== undefined)
            reflectionMergePartial<CreateTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTaskPushNotificationConfigRequest): CreateTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string config_id */ 2:
                    message.configId = reader.string();
                    break;
                case /* a2a.v1.TaskPushNotificationConfig config */ 3:
                    message.config = TaskPushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* string config_id = 2; */
        if (message.configId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.configId);
        /* a2a.v1.TaskPushNotificationConfig config = 3; */
        if (message.config)
            TaskPushNotificationConfig.internalBinaryWrite(message.config, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.CreateTaskPushNotificationConfigRequest
 */
export const CreateTaskPushNotificationConfigRequest = new CreateTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskSubscriptionRequest$Type extends MessageType<TaskSubscriptionRequest> {
    constructor() {
        super("a2a.v1.TaskSubscriptionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskSubscriptionRequest>): TaskSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<TaskSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskSubscriptionRequest): TaskSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.TaskSubscriptionRequest
 */
export const TaskSubscriptionRequest = new TaskSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTaskPushNotificationConfigRequest$Type extends MessageType<ListTaskPushNotificationConfigRequest> {
    constructor() {
        super("a2a.v1.ListTaskPushNotificationConfigRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListTaskPushNotificationConfigRequest>): ListTaskPushNotificationConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parent = "";
        message.pageSize = 0;
        message.pageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListTaskPushNotificationConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTaskPushNotificationConfigRequest): ListTaskPushNotificationConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* int32 page_size */ 2:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 3:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTaskPushNotificationConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.parent);
        /* int32 page_size = 2; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.pageSize);
        /* string page_token = 3; */
        if (message.pageToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ListTaskPushNotificationConfigRequest
 */
export const ListTaskPushNotificationConfigRequest = new ListTaskPushNotificationConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAgentCardRequest$Type extends MessageType<GetAgentCardRequest> {
    constructor() {
        super("a2a.v1.GetAgentCardRequest", []);
    }
    create(value?: PartialMessage<GetAgentCardRequest>): GetAgentCardRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAgentCardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAgentCardRequest): GetAgentCardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAgentCardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.GetAgentCardRequest
 */
export const GetAgentCardRequest = new GetAgentCardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendMessageResponse$Type extends MessageType<SendMessageResponse> {
    constructor() {
        super("a2a.v1.SendMessageResponse", [
            { no: 1, name: "task", kind: "message", oneof: "payload", T: () => Task },
            { no: 2, name: "msg", kind: "message", jsonName: "message", oneof: "payload", T: () => Message }
        ]);
    }
    create(value?: PartialMessage<SendMessageResponse>): SendMessageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SendMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendMessageResponse): SendMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.Task task */ 1:
                    message.payload = {
                        oneofKind: "task",
                        task: Task.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).task)
                    };
                    break;
                case /* a2a.v1.Message msg = 2 [json_name = "message"] */ 2:
                    message.payload = {
                        oneofKind: "msg",
                        msg: Message.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).msg)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.Task task = 1; */
        if (message.payload.oneofKind === "task")
            Task.internalBinaryWrite(message.payload.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.Message msg = 2 [json_name = "message"]; */
        if (message.payload.oneofKind === "msg")
            Message.internalBinaryWrite(message.payload.msg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.SendMessageResponse
 */
export const SendMessageResponse = new SendMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamResponse$Type extends MessageType<StreamResponse> {
    constructor() {
        super("a2a.v1.StreamResponse", [
            { no: 1, name: "task", kind: "message", oneof: "payload", T: () => Task },
            { no: 2, name: "msg", kind: "message", jsonName: "message", oneof: "payload", T: () => Message },
            { no: 3, name: "status_update", kind: "message", oneof: "payload", T: () => TaskStatusUpdateEvent },
            { no: 4, name: "artifact_update", kind: "message", oneof: "payload", T: () => TaskArtifactUpdateEvent }
        ]);
    }
    create(value?: PartialMessage<StreamResponse>): StreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamResponse): StreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* a2a.v1.Task task */ 1:
                    message.payload = {
                        oneofKind: "task",
                        task: Task.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).task)
                    };
                    break;
                case /* a2a.v1.Message msg = 2 [json_name = "message"] */ 2:
                    message.payload = {
                        oneofKind: "msg",
                        msg: Message.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).msg)
                    };
                    break;
                case /* a2a.v1.TaskStatusUpdateEvent status_update */ 3:
                    message.payload = {
                        oneofKind: "statusUpdate",
                        statusUpdate: TaskStatusUpdateEvent.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).statusUpdate)
                    };
                    break;
                case /* a2a.v1.TaskArtifactUpdateEvent artifact_update */ 4:
                    message.payload = {
                        oneofKind: "artifactUpdate",
                        artifactUpdate: TaskArtifactUpdateEvent.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).artifactUpdate)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* a2a.v1.Task task = 1; */
        if (message.payload.oneofKind === "task")
            Task.internalBinaryWrite(message.payload.task, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.Message msg = 2 [json_name = "message"]; */
        if (message.payload.oneofKind === "msg")
            Message.internalBinaryWrite(message.payload.msg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.TaskStatusUpdateEvent status_update = 3; */
        if (message.payload.oneofKind === "statusUpdate")
            TaskStatusUpdateEvent.internalBinaryWrite(message.payload.statusUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* a2a.v1.TaskArtifactUpdateEvent artifact_update = 4; */
        if (message.payload.oneofKind === "artifactUpdate")
            TaskArtifactUpdateEvent.internalBinaryWrite(message.payload.artifactUpdate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.StreamResponse
 */
export const StreamResponse = new StreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTaskPushNotificationConfigResponse$Type extends MessageType<ListTaskPushNotificationConfigResponse> {
    constructor() {
        super("a2a.v1.ListTaskPushNotificationConfigResponse", [
            { no: 1, name: "configs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TaskPushNotificationConfig },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListTaskPushNotificationConfigResponse>): ListTaskPushNotificationConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configs = [];
        message.nextPageToken = "";
        if (value !== undefined)
            reflectionMergePartial<ListTaskPushNotificationConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTaskPushNotificationConfigResponse): ListTaskPushNotificationConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated a2a.v1.TaskPushNotificationConfig configs */ 1:
                    message.configs.push(TaskPushNotificationConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTaskPushNotificationConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated a2a.v1.TaskPushNotificationConfig configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            TaskPushNotificationConfig.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message a2a.v1.ListTaskPushNotificationConfigResponse
 */
export const ListTaskPushNotificationConfigResponse = new ListTaskPushNotificationConfigResponse$Type();
/**
 * @generated ServiceType for protobuf service a2a.v1.A2AService
 */
export const A2AService = new ServiceType("a2a.v1.A2AService", [
    { name: "SendMessage", options: { "google.api.http": { post: "/v1/message:send", body: "*" } }, I: SendMessageRequest, O: SendMessageResponse },
    { name: "SendStreamingMessage", serverStreaming: true, options: { "google.api.http": { post: "/v1/message:stream", body: "*" } }, I: SendMessageRequest, O: StreamResponse },
    { name: "GetTask", options: { "google.api.http": { get: "/v1/{name=tasks/*}" }, "google.api.method_signature": ["name"] }, I: GetTaskRequest, O: Task },
    { name: "CancelTask", options: { "google.api.http": { post: "/v1/{name=tasks/*}:cancel", body: "*" } }, I: CancelTaskRequest, O: Task },
    { name: "TaskSubscription", serverStreaming: true, options: { "google.api.http": { get: "/v1/{name=tasks/*}:subscribe" } }, I: TaskSubscriptionRequest, O: StreamResponse },
    { name: "CreateTaskPushNotificationConfig", options: { "google.api.http": { post: "/v1/{parent=task/*/pushNotificationConfigs}", body: "config" }, "google.api.method_signature": ["parent,config"] }, I: CreateTaskPushNotificationConfigRequest, O: TaskPushNotificationConfig },
    { name: "GetTaskPushNotificationConfig", options: { "google.api.http": { get: "/v1/{name=tasks/*/pushNotificationConfigs/*}" }, "google.api.method_signature": ["name"] }, I: GetTaskPushNotificationConfigRequest, O: TaskPushNotificationConfig },
    { name: "ListTaskPushNotificationConfig", options: { "google.api.http": { get: "/v1/{parent=tasks/*}/pushNotificationConfigs" }, "google.api.method_signature": ["parent"] }, I: ListTaskPushNotificationConfigRequest, O: ListTaskPushNotificationConfigResponse },
    { name: "GetAgentCard", options: { "google.api.http": { get: "/v1/card" } }, I: GetAgentCardRequest, O: AgentCard },
    { name: "DeleteTaskPushNotificationConfig", options: { "google.api.http": { delete: "/v1/{name=tasks/*/pushNotificationConfigs/*}" }, "google.api.method_signature": ["name"] }, I: DeleteTaskPushNotificationConfigRequest, O: Empty }
]);
